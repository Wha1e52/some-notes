<?php

/*
Illuminate\Http\Request
Есть также глобальная вспомогательная функция request() и фасад Request, которые предлагают одни и те же методы


// возвращает массив, содержащий все входные данные, предоставленные пользователем, из всех источников.
$request->all()

// возвращает тот же массив, что и $request->all(), но дополнительно позволяет исключить одно или несколько полей
$request->except()

// функция, обратная $request->except()
$request->only()

// позволяет получить значение только одного поля (второй параметр — значение по умолчанию)
$userName = $request->input('name', 'Matt');

// можно определить, доступно ли конкретное поле в пользовательском вводе, независимо от наличия в нем какого-либо значения
$request->has()

// функция, обратная $request->has().
$request->missing()

// можно определить действия, которые будут выполняться при наличии или отсутствии определенного поля в пользовательском вводе
В первом параметре этот метод принимает имя ожидаемого поля,
во втором — замыкание, которое будет вызвано, если поле присутствует, а в третьем — если отсутствует.
$utm = $request->whenHas('utm', function($utm) {
    return $utm;
}, function() {
    return 'default';
});

// можно проверить, присутствует ли и заполнено ли определенное поле в запросе.
Он действует подобно has(), но дополнительно требует наличия фактического значения в поле
$request->filled()

// По аналогии с методом whenHas() метод $request->whenFilled() позволяет определять действия,
которые будут выполняться при наличии или отсутствии данных в конкретном поле пользовательского ввода
$utm = $request->whenFilled('utm', function ($utm) {
    return $utm;
}, function() {
    return 'default';
});

// можно добавить поле в запрос, если оно отсутствует, и задать его значение
$shouldSend = $request->mergeIfMissing('send_newsletter', 0);

// возвращает команду HTTP для запроса
$request->method()

// проверяет, соответствует ли команда HTTP указанной команде
$request->isMethod('patch')

// преобразуют входные данные в целые числа, числа с плавающей точкой, строки или перечисления соответственно
$request->integer(), $request->float(), $request->string() и $request->enum()

$request->integer('some_integer')
...
$request->enum('subscription', SubscriptionStatusEnum::class)

// $request->dump() и $request->dd() вспомогательные методы для получения дампа запроса
Оба метода выводят полный дамп запроса, если вызываются без параметров, или только выбранные поля, если им передать массив.
$request->dump() выводит дамп и затем выполнение продолжается, а $request->dd() выводит дамп и останавливает выполнение скрипта

// Использование нотации с точкой для доступа к значениям массива в пользовательских данных
$employeeZeroFirstName = $request->input('employees.0.firstName');
$allLastNames = $request->input('employees.*.lastName');
$employeeOne = $request->input('employees.1');

// если в запросе POST отсутствует правильно оформленный заголовок application/json,
то $request->input() не будет воспринимать содержимое как JSON, а $request->json() будет
$request->json()

// возвращает массив всех сегментов URL
$request->segments()
    Сегменты возвращаются на основе индексов, отсчет которых начинается с 1
    (Например, http://www.myapp.com/users/15/ имеет два сегмента: users и 15)
// позволяет получить значение одного сегмента URL
$request->segment($segmentId)

// выгрузка файлов $request->file()
Правильная кодировка формы для выгрузки файлов enctype="multipart/form-data"

<form method="post" enctype="multipart/form-data">
    @csrf
    <input type="text" name="name">
    <input type="file" name="profile_picture">
    <input type="submit">
</form>

Route::post('form', function (Request $request) {
    if ($request->hasFile('profile_picture') && $request->file('profile_picture')->isValid()) {
        //
    }
});

Класс UploadedFile Symfony расширяет PHP-класс SplFileInfo методами, позволяющими исследовать файлы и управлять ими.
Этот список не исчерпывающий, но дает представление о возможностях:
guessExtension();
getMimeType();
store($path, $storageDisk = default disk); (В первом параметре он принимает каталог назначения, а во втором, необязательном параметре — диск хранения (s3, local и т. д.))
storeAs($path, $newName, $storageDisk = default disk);
storePublicly($path, $storageDisk = default disk);
storePubliclyAs($path, $newName, $storageDisk = default disk);
move($directory, $newName = null);
getClientOriginalName();
getClientOriginalExtension();
getClientMimeType();
guessClientExtension();
getClientSize();
getError();
isValid().

// Типичный процесс обработки выгруженного файла
if ($request->hasFile('profile_picture')) {
    $path = $request->profile_picture->store('profiles', 's3');
    auth()->user()->profile_picture = $path;
    auth()->user()->save();
}
Если нужно указать имя файла, можно вместо store() использовать storeAs().

// Захват запроса
Вам вряд ли когда-либо потребуется это в приложении Laravel,
но при необходимости можно захватить объект Illuminate Request непосредственно из глобальных переменных языка PHP,
используя метод capture():
$request = Illuminate\Http\Request::capture();

// Три способа получения объекта Request
Первый - Указание подсказки типа в распознаваемом контейнером методе
...
use Illuminate\Http\Request;
class PeopleController extends Controller
{
    public function index(Request $request)
    {
        $allInput = $request->all();
    }
}
Второй способ — воспользоваться глобальной вспомогательной функцией request(),
вызывая для нее методы (например, request()->input()) или непосредственно ее саму для получения экземпляра $request:
$request = request();
$allInput = $request->all();
// или
$allInput = request()->all();
Третий — вызвать глобальный метод app(). При этом можно передать методу полное имя класса или короткий псевдоним request:
$request = app(Illuminate\Http\Request::class);
$request = app('request');

// методы для получения пользовательского ввода
all() // Возвращает массив из всех введенных пользователем данных.
input(имяПоля) // Возвращает введенное пользователем значение одного поля ввода.
only(имяПоля|[массив,из,имен,полей]) // Возвращает массив из всех введенных пользователем данных для указанных полей ввода.
except(имяПоля|[массив,из,имен,полей]) // Возвращает массив из всех введенных пользователем данных, за исключением указанных полей ввода.
exists(имяПоля) // Возвращает логическое значение, указывающее, присутствует ли указанное поле во входных данных. Имеет псевдоним has().
filled(имяПоля) // Возвращает логическое значение, указывающее, присутствует ли указанное поле во входных данных и заполнено ли оно (то есть имеет ли оно значение).
whenFilled() // Выполняет заданный обратный вызов, когда поле присутствует во входных данных и заполнено (то есть имеет значение).
json() // Возвращает объект ParameterBag, если странице было отправлено JSON-сообщение.
boolean(имяПоля) // Возвращает логическое значение, соответствующее значению указанного поля. Строки и целые числа преобразуются с использованием FILTER_VALIDATE_BOOLEAN. Если поле в запросе отсутствует, возвращается false.
json(имяКлюча) // Извлекает значение указанного ключа из JSON-сообщения, отправленного странице.


// Получение из запроса основного пользовательского ввода
Форма
<form method="POST" action="/form">
    @csrf
    <input name="name"> Name<br>
    <input type="submit">
</form>
Маршрут приема формы
Route::post('form', function (Request $request) {
    echo 'name is ' . $request->input('name') . '<br>';
    echo 'all input is ' . print_r($request->all()) . '<br>';
    echo 'user provided email address: ' . $request->has('email') ? 'true' : 'false';
});

// Пользователь и статус запроса
method() // Возвращает метод (GET, POST, PATCH и т. д.), используемый для доступа к данному маршруту.
path() // Возвращает путь (без домена), применяемый для доступа к данной странице. Например, для 'http://www.myapp.com/abc/def' будет возвращен путь 'abc/def'.
url() // Возвращает URL (с доменом), используемый для доступа к данной странице. Например, для 'abc' будет возвращен URL 'http://www.myapp.com/abc'.
is() // Возвращает логическое значение, указывающее, имеется ли частичное совпадение текущего запроса страницы с предоставленной строкой. Например, оценка на совпадение $request->is('*b*'), где * обозначает любые символы, даст положительный результат для запроса /a/b/c. Данный метод использует собственный синтаксический анализатор регулярных выражений, определенный в методе Str::is().
ip() // Возвращает IP-адрес пользователя.
header() // Возвращает массив заголовков (например, ['accept-language' => ['en-US,en;q=0.8']]) или только указанный заголовок, если в качестве параметра передается имя заголовка.
server() // Возвращает массив переменных, обычно хранящихся в переменной $_SERVER (таких как REMOTE_ADDR), или возвращает только ее значение, если передается имя отдельной переменной.
secure() // Возвращает логическое значение, указывающее, была ли данная страница загружена с использованием протокола HTTPS.
pjax() // Возвращает логическое значение, указывающее, был ли данный запрос страницы загружен с использованием плагина Pjax.
wantsJson() // Возвращает логическое значение, указывающее, присутствуют ли типы содержимого /json в заголовках Accept данного запроса.
isJson() // Возвращает логическое значение, указывающее, присутствуют ли типы содержимого /json в заголовке Content-Type данного запроса страницы.
accepts() // Возвращает логическое значение, указывающее, принимает ли данный запрос страницы содержимое указанного типа


// Файлы

file() // Возвращает массив из всех загруженных на сервер файлов или только один файл, если передается ключ (имя поля для загрузки файла на сервер).
allFiles() // Возвращает массив из всех загруженных на сервер файлов. В отличие от file(), имя этого метода лучше отражает его смысл.
hasFile() // Возвращает логическое значение, указывающее, был ли загружен на сервер соответствующий указанному ключу файл.


// Долговременное хранение

flash() // Сохраняет в сессии пользовательский ввод текущего запроса для последующего извлечения. Эти данные сохраняются в сессии, но исчезают после следующего запроса.
flashOnly() // Сохраняет пользовательский ввод текущего запроса, соответствующий ключам, содержащимся в предоставленном массиве.
flashExcept() // Сохраняет пользовательский ввод текущего запроса, за исключением данных, соответствующих ключам, содержащимся в предоставленном массиве.
old() // Возвращает массив, содержащий весь ранее сохраненный пользовательский ввод. Если передается ключ — значение указанного ключа при условии, что оно было ранее сохранено.
flush() // Стирает ранее сохраненный пользовательский ввод.
cookie() // Извлекает из запроса все cookie-файлы или, если передается ключ, извлекает только указанный cookie-файл.
hasCookie() // Возвращает логическое значение, указывающее, присутствует ли в запросе cookie-файл, соответствующий указанному ключу.
Методы flash*() и old() предназначены для сохранения пользовательского ввода и его последующего извлечения, часто после выполнения проверки с отбраковкой некорректных данных.



















*/