"""
todo 1

Конкурентность позволяет одновременно выполнять более одной задачи.
Конкурентность возможна, когда несколько задач может работать независимо друг от друга.
Примерами конкурентного ввода-вывода могут служить одновременная отправка нескольких веб-запросов
или создание одновременных подключений к веб-серверу.

Такое переключение (делать что-то, пока духовка разогревается, переключаться
с одного торта на другой) – пример конкурентного поведения.

Хотя конкурентность подразумевает, что несколько задач выполняется одновременно,
это еще не значит, что они работают параллельно.
Говоря о параллельной работе, мы имеем в виду, что две задачи или более не просто чередуются,
а выполняются строго в одно и то же время.

В случае конкурентности несколько задач работает в течение одного промежутка времени,
но только одна активна в каждый момент. В случае параллелизма несколько задач активно одновременно.
В случае конкурентности мы переключаемся между двумя приложениями.
В случае параллелизма мы активно выполняем два приложения одновременно.

asyncio - библиотека асинхронного ввода-вывода.
Она позволяет исполнять код в рамках модели асинхронного программирования, т. е.
производить сразу несколько операций ввода-вывода, не жертвуя отзывчивостью приложения.

Так что же означают слова «асинхронное программирование»? Что
длительную задачу можно выполнять в фоновом режиме отдельно от
главного приложения. И система не блокируется в ожидании завер-
шения этой задачи, а может заниматься другими вещами, не завися-
щими от ее исхода. Затем, по завершении задачи, мы получим уве-
домление о том, что она все сделала, и сможем обработать результат.


Сопрограмма – это метод, который можно приостановить, если имеется потенциально длительная задача, а затем
возобновить, когда она завершится.

Ключевые слова async и await. Этот синтаксис, общий с другими языками программиро-
вания, например C и JavaScript, позволяет писать асинхронный код
так, что он выглядит как синхронный. Такой асинхронный код про-
ще читать и понимать, поскольку он похож на последовательный код,
с которым большинство программистов хорошо знакомо.

Асинхронный ввод-вывод позволяет приостановить выполнение
метода, встретив операцию ввода-вывода; ожидая завершения этой
операции, работающей в фоновом режиме, мы можем выполнять ка-
кой-нибудь другой код. Это позволяет выполнять одновременно мно-
го операций ввода-вывода и тем самым ускорить работу приложения.

Процессом называется работающее приложение, которому выделена область памяти, недоступная другим приложениям.
На одной машине может работать несколько процессов. Если машина оснащена процессором с несколькими ядрами,
то несколько процессов могут работать одновременно.

Потоки можно представлять себе как облегченные процессы.

У потоков нет своей памяти, они пользуются памятью создавшего их процесса.
Потоки ассоциированы с процессом, создавшим их.
С каждым процессом всегда ассоциирован по меньшей мере один поток, обычно называемый главным.
Процесс может создавать дополнительные потоки, которые обычно называются рабочими или фоновыми.
Эти потоки могут конкурентно выполнять другую работу наряду с главным потоком.
Потоки, как и процессы, могут работать параллельно на многоядерном процессе,
и операционная система может переключаться между ними с помощью квантования времени.


Процессы могут порождать дополнительные потоки, разделяющие память со своим процессом-родителем.
Они могут конкурентно выполнять другую работу, это называется многопоточностью.


Многопоточность полезна только для задач, ограниченных производительностью ввода-вывода, потому что нам мешает
глобальная блокировка интерпретатора

Говоря кратко, GIL не дает Python-процессу исполнять более одной команды байт-кода
в каждый момент времени. Это означает, что, даже если имеется не-
сколько потоков на многоядерной машине, интерпретатор сможет
в каждый момент исполнять только один поток, содержащий напи-
санный на Python код.
Глобальная блокировка интерпретатора препятствует параллельному выполнению нескольких
участков байт-кода. Это означает, что для любых задач, кроме ввода-вывода и еще нескольких мелких исключений,
многопоточность не дает никакого выигрыша в производительности.

Многопоточность не единственный способ добиться конкурентности.
Можно вместо потоков создать несколько конкурентных процессов, это называется многопроцессностью.
В таком случае родительский процесс создает один или более дочерних процессов, которыми
управляет, а затем распределяет между ними работу.

Многопроцессность обычно предпочтительна, когда имеется счетная задача.

Многопроцессные приложения могут конкурентно выполнять несколько команд байт-кода, потому что
у каждого Python-процесса своя собственная GIL.

Глобальная блокировка интерпретатора освобождается на время выполнения операций ввода-вывода.
Это позволяет использовать потоки для конкурентного выполнения ввода-вывода,
но не для выполнения счетного кода, написанного на Python.

Если два или более потоков модифицируют разделяемую переменную, то ее ко-
нечное состояние может оказаться неожиданным, поскольку за-
висит от порядка доступа к переменной со стороны потоков. Эта
ситуация называется состоянием гонки.
Состояния гонки могут возникать, когда два потока одновременно обращаются к одному объекту Python.
Состояние гонки возникает, когда несколько процессов пытается
обратиться к данным примерно в одно и то же время, и чревато
трудно воспроизводимыми ошибками.

Цикл событий – По сути своей цикл событий очень прост. Мы создаем очередь,
в которой хранится список событий или сообщений, а затем входим в бес-
конечный цикл, где обрабатываем сообщения по мере их поступления.

Создавая цикл событий, мы создаем пустую очередь задач. Затем
добавляем в эту очередь задачи для выполнения. На каждой ите-
рации цикла проверяется, есть ли в очереди готовая задача, и если
да, то она выполняется, пока не встретит операцию ввода-вывода.
В этот момент задача приостанавливается, и мы просим операцион-
ную систему наблюдать за ее сокетами. А сами тем временем пере-
ходим к следующей готовой задаче. На каждой итерации проверяет-
ся, завершилась ли какая-нибудь операция ввода-вывода; если да, то
ожидавшие ее завершения задачи пробуждаются и им предоставля-
ется возможность продолжить работу.



Thread.start() - метод потока, запускающий поток.
Thread.join() - метод потока, который приостанавливает программу, до тех пор пока указанный поток не завершится.
________________________________________________________________________________________________________________________
todo 2

Сопрограмму можно рассматривать как обычную функцию Python, наделенную сверхспособностью:
приостанавливаться, встретив операцию, для выполнения которой нужно заметное время.
По завершении такой длительной операции сопрограмму можно «пробудить», после чего она продолжит выполнение.
Пока приостановленная сопрограмма ждет завершения операции, мы можем выполнять другой код.

Для создания и приостановки сопрограммы нам придется использовать ключевые слова Python async и await.
Слово async определяет сопрограмму, а слово await приостанавливает ее на время выполнения длительной операции.

Важный момент – сопрограммы не выполняются, если их вызвать напрямую. Вместо этого возвращается объект сопрограммы,
который будет выполнен позже. Чтобы выполнить сопрограмму, мы должны явно передать ее циклу событий.

непосредственный вызов сопрограммы не пе-
редает ее циклу событий для выполнения. Вместо этого мы получаем
объект сопрограммы, который нужно затем использовать совместно
с ключевым словом await или передать функции asyncio.run, чтобы
получить возвращенное значение. Располагая только этими инстру-
ментами, мы можем написать асинхронный код, но не можем выпол-
нить его конкурентно. А чтобы это сделать, нужны задачи.

Задача – это обертка вокруг сопрограммы, которая планирует вы-
полнение последней в цикле событий как можно раньше. И плани-
рование, и выполнение происходят в неблокирующем режиме, т. е.,
создав задачу, мы можем сразу приступить к выполнению другого
кода, пока эта задача работает в фоне.

delay_task = asyncio.create_task(delay(2))


В точке, где встречается первое после создания задачи предложение await, все
ожидающие задачи начинают выполняться, так как await запускает очередную итерацию цикла событий.

Важно отметить, что исключение CancelledError может быть воз-
буждено только внутри предложения await. То есть, если вызвать ме-
тод cancel, когда задача исполняет Python-код, этот код будет про-
должать работать, пока не встретится следующее предложение await
(если встретится), и только тогда будет возбуждено исключение CancelledError.
Вызов cancel не прерывает задачу, делающую свое дело;
он снимает ее, только если она уже находится в точке ожидания или
когда дойдет до следующей такой точки.


asyncio.wait_for принимает объект сопрограммы или задачи и тайм-аут в секундах и возвращает сопрограмму,
к которой можно применить await. Если задача не завершилась в отведенное время,
то возбуждается исключение TimeoutError и задача автоматически снимается.

async def main():
    delay_task = asyncio.create_task(delay(2))
    try:
        result = await asyncio.wait_for(delay_task, timeout=3)
        print(result)
    except asyncio.exceptions.TimeoutError:
        print('Тайм-аут!')
        print(f'Задача была снята? {delay_task.cancelled()}')
asyncio.run(main())

в некоторых случаях желательно дать сопрограмме поработать. Например, по прошествии некоторого времени
мы можем проинформировать пользователя о том, что работа занимает дольше, чем ожидалось, но не снимать ее,
когда тайм-аут истечет.
asyncio.shield. предотвращает снятие сопрограммы, снабжая ее «щитом», позволяющим игнорировать запросы на снятие.
await asyncio.wait_for(asyncio.shield(task), 5)

Объект future в Python содержит одно значение, которое мы ожидаем
получить в будущем, но пока еще, возможно, не получили. Обычно
в момент создания future не обертывает никакого значения, потому
что его еще не существует. Объект в таком состоянии называется не-
полным, неразрешенным или просто неготовым. И только получив
результат, мы можем установить значение объекта future, в резуль-
тате чего он становится полным и из него можно извлечь результат.

Мы не вызываем метод result, прежде чем ре-
зультат установлен, потому что тогда он возбудил бы исключе-
ние InvalidState.

Между задачами и будущими объектами существует тесная связь. На
самом деле task напрямую наследует future. Можно считать, что объ-
ект future представляет значение, которое появится только в буду-
щем. А task является комбинацией сопрограммы и future. Создавая
задачу, мы создаем пустой объект future и запускаем сопрограмму.
А когда сопрограмма завершится с результатом или вследствие ис-
ключения, мы записываем этот результат или объект-исключение во
future.

Любой объект, который реализует метод __await__, можно использовать
в выражении await. Сопрограммы, как и будущие объекты, наследуют
Awaitable напрямую, задачи же расширяют будущие объекты.

Есть две основные ошибки на пути преобразования приложения
в асинхронное. Первая – попытка выполнить счетный код в задачах
или сопрограммах, не прибегая к многопроцессности, вторая – ис-
пользовать блокирующие API ввода-вывода, пренебрегая многопо-
точностью.

Вообще, любая функция, которая выполняет
ввод-вывод, не являясь сопрограммой, или занимает процессор дли-
тельными операциями, может считаться блокирующей.

Кроме того, могут понадобиться методы самого цикла событий. Как
правило, они низкоуровневые, так что злоупотреблять ими не стоит.
если нужно сделать что-то нестандартное, например работать
с сокетами напрямую или запланировать задачу на конкретный мо-
мент в будущем, то доступ к циклу событий необходим.

import asyncio

async def main():
    await asyncio.sleep(1)
loop = asyncio.new_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()

Это похоже на то, что происходит при вызове asyncio.run, с той
разницей, что оставшиеся задачи не отменяются. Если нам нужна
специальная логика очистки, то ее следует реализовать в предложе-
нии finally.

Иногда бывает необходим доступ к текущему циклу событий. Библиотека
asyncio предоставляет для этой цели функцию asyncio.get_running_
loop. В качестве примера рассмотрим метод call_soon, который
планирует выполнение функции на следующей итерации цикла со-
бытий.

def call_later():
    print("Меня вызовут в ближайшем будущем!")

async def main():
    loop = asyncio.get_running_loop()
    loop.call_soon(call_later)
    await delay(1)
asyncio.run(main())

Отладочный режим
asyncio.run(coroutine(), debug=True)
python3 -X dev program.py

async def main():
    loop = asyncio.get_event_loop()
    loop.slow_callback_duration = .250
asyncio.run(main(), debug=True)

Здесь продолжительность медленного обратного вызова установ-
лена равной 250 мс, т. е. сообщение печатается, если сопрограмма ра-
ботает дольше 250 мс.
________________________________________________________________________________________________________________________
todo 3

Сопрограммы цикла событий для сокетов
Поскольку сокеты – сравнительно низкоуровневое понятие, методы
для работы с ними принадлежат самому циклу событий. Нам пред-
стоит работать с тремя основными сопрограммами: sock_accept,
sock_recv и sock_sendall. Это аналоги рассмотренных выше мето-
дов класса socket, только принимают они сокет в качестве аргумента
и возвращают сопрограммы, которые могут ждать поступления дан-
ных с помощью await.
Начнем с sock_accept. Эта сопрограмма аналогична методу socket.
accept, который мы видели в самой первой реализации. Она возвра-
щает кортеж (структуру данных, в которой хранится упорядоченная
последовательность значений), состоящий из сокета и адреса клиен-
та. Мы передаем серверный сокет и ждем, когда сопрограмма что-то
вернет. После этого мы будем иметь подключенный сокет и адрес. Со-
кет должен быть неблокирующим и уже привязанным к порту:
connection, address = await loop.sock_accept(socket)
Методы sock_recv и sock_sendall названы по аналогии с sock_accept.
Они принимают сокет и ждут результата. sock_recv ждет по-
ступления байтов в сокет. sock_sendall принимает сокет и данные,
которые нужно отправить, после чего ждет, пока все данные будут от-
правлены. В случае успеха sock_sendall возвращает None.
data = await loop.sock_recv(socket)
success = await loop.sock_sendall(socket, data)
________________________________________________________________________________________________________________________
todo 4

Пул подключений - внутри сеанса хранится много открытых подключений, их можно при
необходимости использовать повторно. Пул подключений играет важную роль в производительности приложений
на базе aiohttp. Поскольку создание подключения – дорогостоящее
действие, наличие пула повторно используемых подключений сокра-
щает затраты на выделение и освобождение ресурсов. Сеанс также
самостоятельно сохраняет все полученные куки.

Отметим, что по умолчанию в сеансе ClientSession можно создать
не более 100 подключений, что дает неявную верхнюю границу коли-
чества конкурентных веб-запросов. Чтобы изменить этот предел, мож-
но создать экземпляр класса TCPConnector, входящего в состав aiohttp,
указав максимальное число подключений, и передать его конструкто-
ру ClientSession.

в aiohttp по умолчанию тайм-аут равен 5 мин.
Тайм-аут можно задавать на уровне сеанса, тогда он будет применяться к каждой операции, или на
уровне запроса, если требуется более точное управление.
Тайм-аут задается с помощью структуры данных aiohttp Client-Timeout.

async def fetch_status(session: ClientSession, url: str) -> int:
    ten_millis = aiohttp.ClientTimeout(total=.01)
    async with session.get(url, timeout=ten_millis) as result:
        return result.status


async def main():
    session_timeout = aiohttp.ClientTimeout(total=1, connect=.1)
    async with aiohttp.ClientSession(timeout=session_timeout) as session:
        await fetch_status(session, 'https://example.com')

Здесь задается два тайм-аута. Первый – на уровне клиентского
сеанса, полный тайм-аут равен 1 с, а тайм-аут для установления со-
единения – 100 мс. Затем в функции fetch_status мы переопределя-
ем этот тайм-аут для нашего GET-запроса, задавая его равным 10 мс.
Если запрос к example.com займет более 10 мс, то будет возбуждено
исключение asyncio.TimeoutError в точке await fetch_status.

Для конкурентного выполнения допускающих ожидание объектов
широко используется функция asyncio.gather. Она принимает по-
следовательность допускающих ожидание объектов и запускает их
конкурентно всего в одной строке кода.
Если среди объектов есть сопрограмма, то gather автоматически обертывает ее задачей,
чтобы гарантировать конкурентное выполнение. Это значит, что не нужно
отдельно обертывать все сопрограммы по отдельности с помощью
функции asyncio.create_task, как мы делали раньше.
asyncio.gather возвращает объект, допускающий ожидание. Если
использовать его в выражении await, то выполнение будет приоста-
новлено, пока не завершатся все переданные объекты. А когда это
произойдет, asyncio.gather вернет список результатов работы.

Стоит отметить, что порядок поступления результатов для пере-
данных объектов, допускающих ожидание, не детерминирован. На-
пример, если передать gather сопрограммы a и b именно в таком
порядке, то b может завершиться раньше, чем a. Но приятная особен-
ность gather заключается в том, что, независимо от порядка завер-
шения допускающих ожидание объектов, результаты гарантирован-
но будут возвращены в том порядке, в каком объекты передавались.
Функция gather гарантирует детерминированный порядок результатов, несмотря на
недетерминированность их получения. На внутреннем уровне gather
использует для этой цели специальную реализацию future.

asyncio.gather принимает необязательный параметр, return_exceptions,
который позволяет указать, как мы хотим обрабатывать ис-
ключения от допускающих ожидание объектов. Это булево значение,
поэтому возможно два варианта:
    return_exceptions=False – это режим по умолчанию. Если хотя
бы одна сопрограмма возбуждает исключение, то gather воз-
буждает то же исключение в точке await. Но, даже если какая-
то сопрограмма откажет, остальные не снимаются и продолжат
работать при условии, что мы обработаем исключение и оно не
приведет к остановке цикла событий и снятию задач;
    return_exceptions=True – в этом случае исключения возвраща-
ются в том же списке, что результаты. Сам по себе вызов gather
не возбуждает исключений, и мы можем обработать исключе-
ния, как нам удобно.


as_completed

Хотя во многих случаях функция asyncio.gather нас устраивает, у нее
есть недостаток – необходимость дождаться завершения всех допу-
скающих ожидания объектов, прежде чем станет возможен доступ
к результатам. Это проблема, если требуется обрабатывать результаты
в темпе их получения. А также в случае, когда одни объекты заверша-
ются быстро, а другие медленно, потому что gather будет ждать за-
вершения всех. В результате приложение может стать неотзывчивым.
Представьте, что пользователь отправил 100 запросов, из которых два
медленные, а остальные быстрые. Было бы хорошо, если бы мы могли
что-то сообщить пользователю, как только начинают поступать ответы.
Для решения этой проблемы asyncio предлагает функцию as_completed.
Она принимает список допускающих ожидание объектов
и возвращает итератор по будущим объектам. Эти объекты можно
перебирать, применяя к каждому await. Когда выражение await вер-
нет управление, мы получим результат первой завершившейся со-
программы. Это значит, что мы сможем обрабатывать результаты по
мере их доступности, но теперь порядок результатов не детермини-
рован, поскольку неизвестно, какой объект завершится первым.
Под капотом каждая сопрограмма обертывается задачей и начинает выполняться конкурентно.
Функция немедленно возвращает итератор, который мы начинаем обходить.

Функция wait в asyncio похожа на gather, но дает более точный
контроль над ситуацией. У нее есть несколько параметров, позво-
ляющих решить, когда мы хотим получить результаты. Кроме того,
она возвращает два множества: задачи, завершившиеся успешно или
в результате исключения, а также задачи, которые продолжают вы-
полняться. Еще эта функция позволяет задать тайм-аут, который, од-
нако, ведет себя не так, как в других функциях API: он не возбуждает
исключений. В тех случаях, когда необходимо, эта функция позволяет
решить некоторые отмеченные выше проблемы, присущие другим
функциям asyncio.
Базовая сигнатура wait – список допускающих ожидание объек-
тов, за которым следует факультативный тайм-аут и факультативный
параметр return_when, который может принимать значения ALL_COMPLETED,
FIRST_EXCEPTION и FIRST_COMPLETED, а по умолчанию равен ALL_
COMPLETED.
________________________________________________________________________________________________________________________
todo 5

В SQL одному подключению к базе соответствует один сокет.
Проблему можно решить, создав несколько под-
ключений к базе, по одному на каждый запрос. Но создание подклю-
чений обходится дорого, поэтому имеет смысл кешировать их и полу-
чать из кеша по мере необходимости. Обычно такой кеш называется
пулом подключений.
Поскольку в каждый момент времени на одном подключении можно
выполнять только один запрос, нам необходим механизм для созда-
ния нескольких подключений и управления ими. Именно таким ме-
ханизмом и является пул подключений.
Пулы обеспечивают повторное использо-
вание подключений. Иными словами, если мы захватываем подклю-
чение из пула для выполнения запроса, то после завершения запроса
подключение «освобождается», т. е. возвращается в пул. Это важно,
потому что создание подключения к базе данных – процесс небы-
стрый.

Циклы async for хороши для обхода всего набора, тогда как создание курсора и метод
fetch удобны для выборки порции записей или пропуска части результирующего набора.

todo: WSGI
- стандартизованный способ передачи запросов веб-фреймворку, например Flask или Django.








"""
import asyncio
import logging
from asyncio import StreamReader, StreamWriter


class ChatServer:
    def __init__(self):
        self._username_to_writer = {}

    async def start_chat_server(self, host: str, port: int):
        server = await asyncio.start_server(self.client_connected, host, port)

        async with server:
            await server.serve_forever()

    async def client_connected(self, reader: StreamReader, writer: StreamWriter):
        command = await reader.readline()
        print(f"CONNECTED {reader} {writer}")
        command, args = command.split(b" ")
        if command == b"CONNECT":
            username = args.replace(b"\n", b"").decode()
            self._add_user(username, reader, writer)
            await self._on_connect(username, writer)
        else:
            logging.error("Got invalid command from client, disconnecting.")
            writer.close()
            await writer.wait_closed()

    def _add_user(self, username: str, reader: StreamReader, writer: StreamWriter):
        self._username_to_writer[username] = writer
        asyncio.create_task(self._listen_for_messages(username, reader))

    async def _on_connect(self, username: str, writer: StreamWriter):
        writer.write(
            f"Welcome! {len(self._username_to_writer)} user(s) are online!\n".encode()
        )
        await writer.drain()
        await self._notify_all(f"{username} connected!\n")

    async def _remove_user(self, username: str):
        writer = self._username_to_writer[username]
        del self._username_to_writer[username]
        try:
            writer.close()
            await writer.wait_closed()
        except Exception as e:
            logging.exception("Error closing client writer, ignoring.", exc_info=e)

    async def _listen_for_messages(self, username: str, reader: StreamReader):
        try:
            while (data := await asyncio.wait_for(reader.readline(), 60)) != b"":
                await self._notify_all(f"{username}: {data.decode()}")
            await self._notify_all(f"{username} has left the chat\n")
        except Exception as e:
            logging.exception("Error reading from client.", exc_info=e)
            await self._remove_user(username)

    async def _notify_all(self, message: str):
        inactive_users = []
        for username, writer in self._username_to_writer.items():
            try:
                writer.write(message.encode())
                await writer.drain()
            except ConnectionError as e:
                logging.exception("Could not write to client.", exc_info=e)
                inactive_users.append(username)

        [await self._remove_user(username) for username in inactive_users]


async def main():
    chat_server = ChatServer()
    await chat_server.start_chat_server("localhost", 8000)


asyncio.run(main())