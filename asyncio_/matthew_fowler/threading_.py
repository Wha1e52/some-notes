"""
Интерпретатор Python однопоточный в том смысле, что в каждый
момент времени может выполняться только один участок байт-кода,
даже если в процессе работает несколько потоков.
Глобальная блокировка интерпретатора не позволяет выполнять несколько потоков одновременно.

todo: Демоны
- это специальный вид потоков, предназначенный для выполнения
длительных фоновых задач. Они не мешают приложению завершить-
ся. На самом деле если работают только потоки-демоны, то прило-
жение вообще завершается автоматически. Главный поток Python не
является демоном, но если все потоки обслуживания подключений
сделать демонами, то приложение завершится при возникновении
KeyboardInterrupt.

Потоки-демоны завершаются без уведомления, и мы не можем выполнить в этот момент никакой код очистки.

todo: Что такое «активный» поток
Поток называется активным, если исполняется его метод run;

Вообще говоря, снятие работающих потоков в Python и не только –
непростая задача, решение которой зависит от конкретной ситуации.
Нужно принимать специальные меры, чтобы потоки не помешали
приложению завершиться, и решить, в каком месте размещать точки
прерывания для выхода из потока.

Если пул процессов по умолчанию создает по одному рабочему
процессу для каждого имеющегося процессорного ядра, то определе-
ние количества рабочих потоков несколько сложнее. По умолчанию
оно равно min(32, os.cpu_count() + 4). Это значит, что максимальное
число потоков в пуле равно 32, а минимальное 5.

Потоки создаются на уровне операционной системы и обходятся дороже сопрограмм.
К тому же у контекстного переключения потоков на уровне ОС тоже
есть цена. Сохранение и восстановление состояния потока при кон-
текстном переключении съедает часть выигрыша, полученного от ис-
пользования потоков.

Всякий раз, как два потока или процесса потенциально могут изменить разделяемый
элемент данных, следует использовать блокировку для синхрониза-
ции доступа. Для этого нам понадобится реализация класса Lock в модуле threading, отличающаяся от реализации
в модуле multiprocessing. Нужно лишь импортировать Lock из threading
и окружить критические секции вызовами его методов acquire
и release либо пометить их внутрь контекстного менеджера.

Если вы разрабатываете потокобезопасный класс с методом A, который за-
хватывает блокировку, и методом B, который также захватывает бло-
кировку и вызывает метод A, то, вероятно, нужна реентерабельная
блокировка.

"""





